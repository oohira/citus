SHOW server_version \gset
SELECT substring(:'server_version', '\d+')::int >= 15 AS server_version_ge_15
\gset
\if :server_version_ge_15
\else
\q
\endif
-- MERGE command performs a join from data_source to target_table_name
DROP SCHEMA IF EXISTS merge_schema CASCADE;
NOTICE:  schema "merge_schema" does not exist, skipping
--MERGE INTO target
--USING source
--WHEN NOT MATCHED
--WHEN MATCHED AND <condition>
--WHEN MATCHED
CREATE SCHEMA merge_schema;
SET search_path TO merge_schema;
SET citus.shard_count TO 4;
SET citus.next_shard_id TO 4000000;
SET citus.explain_all_tasks to true;
SELECT 1 FROM master_add_node('localhost', :master_port, groupid => 0);
NOTICE:  Replicating reference table "orders_reference" to the node localhost:xxxxx
NOTICE:  Replicating reference table "customer" to the node localhost:xxxxx
NOTICE:  Replicating reference table "nation" to the node localhost:xxxxx
NOTICE:  Replicating reference table "part" to the node localhost:xxxxx
NOTICE:  Replicating reference table "supplier" to the node localhost:xxxxx
NOTICE:  Replicating reference table "users_table_2" to the node localhost:xxxxx
NOTICE:  localhost:xxxxx is the coordinator and already contains metadata, skipping syncing the metadata
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM master_set_node_property('localhost', :master_port, 'shouldhaveshards', true);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

CREATE TABLE source
(
   order_id        INT,
   customer_id     INT,
   order_center    VARCHAR,
   order_time timestamp
);
CREATE TABLE target
(
   customer_id     INT,
   last_order_id   INT,
   order_center    VARCHAR,
   order_count     INT,
   last_order      timestamp
);
CREATE FUNCTION insert_data() RETURNS VOID AS $$

INSERT INTO source (order_id, customer_id, order_center, order_time)
   VALUES (101, 30000, 'WX', '2022-01-01 00:00:00'); -- Do not match
INSERT INTO source (order_id, customer_id, order_center, order_time)
   VALUES (102, 30001, 'CX', '2022-01-01 00:00:00'); -- Do not match

INSERT INTO source (order_id, customer_id, order_center, order_time)
   VALUES (103, 30002, 'AX', '2022-01-01 00:00:00'); -- Does match
INSERT INTO source (order_id, customer_id, order_center, order_time)
   VALUES (104, 30003, 'JX','2022-01-01 00:00:00' ); -- Does match
INSERT INTO source (order_id, customer_id, order_center, order_time)
   VALUES (105, 30004, 'JX','2022-01-01 00:00:00' ); -- Does match

INSERT INTO target (customer_id, last_order_id, order_center, order_count, last_order)
   VALUES (40000, 097, 'MK', -1, '2019-09-15 08:13:00');
INSERT INTO target (customer_id, last_order_id, order_center, order_count, last_order)
   VALUES (40001, 098, 'NU', -1, '2020-07-12 01:05:00');
INSERT INTO target (customer_id, last_order_id, order_center, order_count, last_order)
   VALUES (40002, 100, 'DS', -1, '2022-05-21 04:12:00');
INSERT INTO target (customer_id, last_order_id, order_center, order_count, last_order)
   VALUES (30002, 103, 'AX', -1, '2021-01-17 19:53:00'); -- Matches the source
INSERT INTO target (customer_id, last_order_id, order_center, order_count, last_order)
   VALUES (30003, 099, 'JX', -1, '2020-09-11 03:23:00'); -- Matches the source
INSERT INTO target (customer_id, last_order_id, order_center, order_count, last_order)
   VALUES (30004, 099, 'XX', -1, '2020-09-11 03:23:00'); -- Matches the source id AND the condition.
$$
LANGUAGE SQL;
SELECT insert_data();
 insert_data
---------------------------------------------------------------------

(1 row)

SELECT 'Testing PG tables';
     ?column?
---------------------------------------------------------------------
 Testing PG tables
(1 row)

MERGE INTO target t
   USING source s
   ON (t.customer_id = s.customer_id)
   WHEN MATCHED AND t.order_center = 'XX' THEN
       DELETE
   WHEN MATCHED THEN
       UPDATE SET     -- Existing customer, update the order count and last_order_id
           order_count = t.order_count + 1,
           last_order_id = s.order_id
   WHEN NOT MATCHED THEN       -- New entry, record it.
       INSERT (customer_id, last_order_id, order_center, order_count, last_order)
           VALUES (customer_id, s.order_id, s.order_center, 123, s.order_time);
-- Our gold result to compare against
SELECT * INTO pg_result FROM target ORDER BY 1 ;
-- Clean the slate
TRUNCATE source;
TRUNCATE target;
SELECT insert_data();
 insert_data
---------------------------------------------------------------------

(1 row)

-- Test with both target and source as Citus local
SELECT 'local - local';
   ?column?
---------------------------------------------------------------------
 local - local
(1 row)

SELECT citus_add_local_table_to_metadata('target');
 citus_add_local_table_to_metadata
---------------------------------------------------------------------

(1 row)

SELECT citus_add_local_table_to_metadata('source');
 citus_add_local_table_to_metadata
---------------------------------------------------------------------

(1 row)

MERGE INTO target t
   USING source s
   ON (t.customer_id = s.customer_id)
   WHEN MATCHED AND t.order_center = 'XX' THEN
       DELETE
   WHEN MATCHED THEN
       UPDATE SET     -- Existing customer, update the order count and last_order_id
           order_count = t.order_count + 1,
           last_order_id = s.order_id
   WHEN NOT MATCHED THEN       -- New entry, record it.
       INSERT (customer_id, last_order_id, order_center, order_count, last_order)
           VALUES (customer_id, s.order_id, s.order_center, 123, s.order_time);
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.target_4000000 t USING merge_schema.source_4000001 s ON (t.customer_id OPERATOR(pg_catalog.=) s.customer_id) WHEN MATCHED AND ((t.order_center COLLATE "default") OPERATOR(pg_catalog.=) 'XX'::text) THEN DELETE WHEN MATCHED THEN UPDATE SET last_order_id = s.order_id, order_count = (t.order_count OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (customer_id, last_order_id, order_center, order_count, last_order) VALUES (s.customer_id, s.order_id, s.order_center, 123, s.order_time)>
SELECT * INTO local_local FROM target ORDER BY 1 ;
-- Should be equal
SELECT c.*, p.*
FROM local_local c, pg_result p
WHERE c.customer_id = p.customer_id
ORDER BY 1,2;
 customer_id | last_order_id | order_center | order_count |        last_order        | customer_id | last_order_id | order_center | order_count |        last_order
---------------------------------------------------------------------
       30000 |           101 | WX           |         123 | Sat Jan 01 00:00:00 2022 |       30000 |           101 | WX           |         123 | Sat Jan 01 00:00:00 2022
       30001 |           102 | CX           |         123 | Sat Jan 01 00:00:00 2022 |       30001 |           102 | CX           |         123 | Sat Jan 01 00:00:00 2022
       30002 |           103 | AX           |           0 | Sun Jan 17 19:53:00 2021 |       30002 |           103 | AX           |           0 | Sun Jan 17 19:53:00 2021
       30003 |           104 | JX           |           0 | Fri Sep 11 03:23:00 2020 |       30003 |           104 | JX           |           0 | Fri Sep 11 03:23:00 2020
       40000 |            97 | MK           |          -1 | Sun Sep 15 08:13:00 2019 |       40000 |            97 | MK           |          -1 | Sun Sep 15 08:13:00 2019
       40001 |            98 | NU           |          -1 | Sun Jul 12 01:05:00 2020 |       40001 |            98 | NU           |          -1 | Sun Jul 12 01:05:00 2020
       40002 |           100 | DS           |          -1 | Sat May 21 04:12:00 2022 |       40002 |           100 | DS           |          -1 | Sat May 21 04:12:00 2022
(7 rows)

-- Must return zero rows
SELECT *
FROM pg_result p
WHERE NOT EXISTS (SELECT FROM local_local c WHERE c.customer_id = p.customer_id);
 customer_id | last_order_id | order_center | order_count | last_order
---------------------------------------------------------------------
(0 rows)

SELECT 'Testing Dist - Dist';
      ?column?
---------------------------------------------------------------------
 Testing Dist - Dist
(1 row)

-- Clean the slate
TRUNCATE source;
TRUNCATE target;
SELECT insert_data();
 insert_data
---------------------------------------------------------------------

(1 row)

SELECT undistribute_table('target');
NOTICE:  creating a new table for merge_schema.target
NOTICE:  moving the data of merge_schema.target
NOTICE:  dropping the old merge_schema.target
NOTICE:  renaming the new table to merge_schema.target
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT undistribute_table('source');
NOTICE:  creating a new table for merge_schema.source
NOTICE:  moving the data of merge_schema.source
NOTICE:  dropping the old merge_schema.source
NOTICE:  renaming the new table to merge_schema.source
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('target', 'customer_id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.target$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('source', 'customer_id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.source$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

MERGE INTO target t
   USING source s
   ON (t.customer_id = s.customer_id)
   WHEN MATCHED AND t.order_center = 'XX' THEN
       DELETE
   WHEN MATCHED THEN
       UPDATE SET     -- Existing customer, update the order count and last_order_id
           order_count = t.order_count + 1,
           last_order_id = s.order_id
   WHEN NOT MATCHED THEN       -- New entry, record it.
       INSERT (customer_id, last_order_id, order_center, order_count, last_order)
           VALUES (customer_id, s.order_id, s.order_center, 123, s.order_time);
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.target_4000002 t USING merge_schema.source_4000006 s ON (t.customer_id OPERATOR(pg_catalog.=) s.customer_id) WHEN MATCHED AND ((t.order_center COLLATE "default") OPERATOR(pg_catalog.=) 'XX'::text) THEN DELETE WHEN MATCHED THEN UPDATE SET last_order_id = s.order_id, order_count = (t.order_count OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (customer_id, last_order_id, order_center, order_count, last_order) VALUES (s.customer_id, s.order_id, s.order_center, 123, s.order_time)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.target_4000003 t USING merge_schema.source_4000007 s ON (t.customer_id OPERATOR(pg_catalog.=) s.customer_id) WHEN MATCHED AND ((t.order_center COLLATE "default") OPERATOR(pg_catalog.=) 'XX'::text) THEN DELETE WHEN MATCHED THEN UPDATE SET last_order_id = s.order_id, order_count = (t.order_count OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (customer_id, last_order_id, order_center, order_count, last_order) VALUES (s.customer_id, s.order_id, s.order_center, 123, s.order_time)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.target_4000004 t USING merge_schema.source_4000008 s ON (t.customer_id OPERATOR(pg_catalog.=) s.customer_id) WHEN MATCHED AND ((t.order_center COLLATE "default") OPERATOR(pg_catalog.=) 'XX'::text) THEN DELETE WHEN MATCHED THEN UPDATE SET last_order_id = s.order_id, order_count = (t.order_count OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (customer_id, last_order_id, order_center, order_count, last_order) VALUES (s.customer_id, s.order_id, s.order_center, 123, s.order_time)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.target_4000005 t USING merge_schema.source_4000009 s ON (t.customer_id OPERATOR(pg_catalog.=) s.customer_id) WHEN MATCHED AND ((t.order_center COLLATE "default") OPERATOR(pg_catalog.=) 'XX'::text) THEN DELETE WHEN MATCHED THEN UPDATE SET last_order_id = s.order_id, order_count = (t.order_count OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (customer_id, last_order_id, order_center, order_count, last_order) VALUES (s.customer_id, s.order_id, s.order_center, 123, s.order_time)>
SELECT * INTO dist_dist FROM target ORDER BY 1 ;
-- Should be equal
SELECT c.*, p.*
FROM dist_dist c, pg_result p
WHERE c.customer_id = p.customer_id
ORDER BY 1,2;
 customer_id | last_order_id | order_center | order_count |        last_order        | customer_id | last_order_id | order_center | order_count |        last_order
---------------------------------------------------------------------
       30000 |           101 | WX           |         123 | Sat Jan 01 00:00:00 2022 |       30000 |           101 | WX           |         123 | Sat Jan 01 00:00:00 2022
       30001 |           102 | CX           |         123 | Sat Jan 01 00:00:00 2022 |       30001 |           102 | CX           |         123 | Sat Jan 01 00:00:00 2022
       30002 |           103 | AX           |           0 | Sun Jan 17 19:53:00 2021 |       30002 |           103 | AX           |           0 | Sun Jan 17 19:53:00 2021
       30003 |           104 | JX           |           0 | Fri Sep 11 03:23:00 2020 |       30003 |           104 | JX           |           0 | Fri Sep 11 03:23:00 2020
       40000 |            97 | MK           |          -1 | Sun Sep 15 08:13:00 2019 |       40000 |            97 | MK           |          -1 | Sun Sep 15 08:13:00 2019
       40001 |            98 | NU           |          -1 | Sun Jul 12 01:05:00 2020 |       40001 |            98 | NU           |          -1 | Sun Jul 12 01:05:00 2020
       40002 |           100 | DS           |          -1 | Sat May 21 04:12:00 2022 |       40002 |           100 | DS           |          -1 | Sat May 21 04:12:00 2022
(7 rows)

-- Must return zero rows
SELECT *
FROM pg_result p
WHERE NOT EXISTS (SELECT FROM dist_dist c WHERE c.customer_id = p.customer_id);
 customer_id | last_order_id | order_center | order_count | last_order
---------------------------------------------------------------------
(0 rows)

-- Test EXPLAIN
EXPLAIN
MERGE INTO target t
   USING source s
   ON (t.customer_id = s.customer_id)
   WHEN MATCHED AND t.order_center = 'XX' THEN
       DELETE
   WHEN MATCHED THEN
       UPDATE SET     -- Existing customer, update the order count and last_order_id
           order_count = t.order_count + 1,
           last_order_id = s.order_id
   WHEN NOT MATCHED THEN       -- New entry, record it.
       INSERT (customer_id, last_order_id, order_center, order_count, last_order)
           VALUES (customer_id, s.order_id, s.order_center, 123, s.order_time);
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.target_4000002 t USING merge_schema.source_4000006 s ON (t.customer_id OPERATOR(pg_catalog.=) s.customer_id) WHEN MATCHED AND ((t.order_center COLLATE "default") OPERATOR(pg_catalog.=) 'XX'::text) THEN DELETE WHEN MATCHED THEN UPDATE SET last_order_id = s.order_id, order_count = (t.order_count OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (customer_id, last_order_id, order_center, order_count, last_order) VALUES (s.customer_id, s.order_id, s.order_center, 123, s.order_time)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.target_4000003 t USING merge_schema.source_4000007 s ON (t.customer_id OPERATOR(pg_catalog.=) s.customer_id) WHEN MATCHED AND ((t.order_center COLLATE "default") OPERATOR(pg_catalog.=) 'XX'::text) THEN DELETE WHEN MATCHED THEN UPDATE SET last_order_id = s.order_id, order_count = (t.order_count OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (customer_id, last_order_id, order_center, order_count, last_order) VALUES (s.customer_id, s.order_id, s.order_center, 123, s.order_time)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.target_4000004 t USING merge_schema.source_4000008 s ON (t.customer_id OPERATOR(pg_catalog.=) s.customer_id) WHEN MATCHED AND ((t.order_center COLLATE "default") OPERATOR(pg_catalog.=) 'XX'::text) THEN DELETE WHEN MATCHED THEN UPDATE SET last_order_id = s.order_id, order_count = (t.order_count OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (customer_id, last_order_id, order_center, order_count, last_order) VALUES (s.customer_id, s.order_id, s.order_center, 123, s.order_time)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.target_4000005 t USING merge_schema.source_4000009 s ON (t.customer_id OPERATOR(pg_catalog.=) s.customer_id) WHEN MATCHED AND ((t.order_center COLLATE "default") OPERATOR(pg_catalog.=) 'XX'::text) THEN DELETE WHEN MATCHED THEN UPDATE SET last_order_id = s.order_id, order_count = (t.order_count OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (customer_id, last_order_id, order_center, order_count, last_order) VALUES (s.customer_id, s.order_id, s.order_center, 123, s.order_time)>
                                            QUERY PLAN
---------------------------------------------------------------------
 Custom Scan (Citus Adaptive)  (cost=0.00..0.00 rows=0 width=0)
   Task Count: 4
   Tasks Shown: All
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  Merge on target_4000002 t  (cost=32.95..247.32 rows=0 width=0)
               ->  Hash Left Join  (cost=32.95..247.32 rows=5457 width=54)
                     Hash Cond: (s.customer_id = t.customer_id)
                     ->  Seq Scan on source_4000006 s  (cost=0.00..20.70 rows=1070 width=48)
                     ->  Hash  (cost=20.20..20.20 rows=1020 width=10)
                           ->  Seq Scan on target_4000002 t  (cost=0.00..20.20 rows=1020 width=10)
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  Merge on target_4000003 t  (cost=32.95..247.32 rows=0 width=0)
               ->  Hash Left Join  (cost=32.95..247.32 rows=5457 width=54)
                     Hash Cond: (s.customer_id = t.customer_id)
                     ->  Seq Scan on source_4000007 s  (cost=0.00..20.70 rows=1070 width=48)
                     ->  Hash  (cost=20.20..20.20 rows=1020 width=10)
                           ->  Seq Scan on target_4000003 t  (cost=0.00..20.20 rows=1020 width=10)
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  Merge on target_4000004 t  (cost=32.95..247.32 rows=0 width=0)
               ->  Hash Left Join  (cost=32.95..247.32 rows=5457 width=54)
                     Hash Cond: (s.customer_id = t.customer_id)
                     ->  Seq Scan on source_4000008 s  (cost=0.00..20.70 rows=1070 width=48)
                     ->  Hash  (cost=20.20..20.20 rows=1020 width=10)
                           ->  Seq Scan on target_4000004 t  (cost=0.00..20.20 rows=1020 width=10)
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  Merge on target_4000005 t  (cost=32.95..247.32 rows=0 width=0)
               ->  Hash Left Join  (cost=32.95..247.32 rows=5457 width=54)
                     Hash Cond: (s.customer_id = t.customer_id)
                     ->  Seq Scan on source_4000009 s  (cost=0.00..20.70 rows=1070 width=48)
                     ->  Hash  (cost=20.20..20.20 rows=1020 width=10)
                           ->  Seq Scan on target_4000005 t  (cost=0.00..20.20 rows=1020 width=10)
(35 rows)

--
-- Test MERGE with CTE as source
--
CREATE TABLE t1(id int, val int);
CREATE TABLE s1(id int, val int);
CREATE FUNCTION load() RETURNS VOID AS $$

INSERT INTO s1 VALUES(1, 0); -- Matches DELETE clause
INSERT INTO s1 VALUES(2, 1); -- Matches UPDATE clause
INSERT INTO s1 VALUES(3, 1); -- No Match INSERT clause
INSERT INTO s1 VALUES(4, 1); -- No Match INSERT clause
INSERT INTO s1 VALUES(6, 1); -- No Match INSERT clause

INSERT INTO t1 VALUES(1, 0); -- Will be deleted
INSERT INTO t1 VALUES(2, 0); -- Will be updated
INSERT INTO t1 VALUES(5, 0); -- Will be intact

$$
LANGUAGE SQL;
SELECT 'Testing PG tables';
     ?column?
---------------------------------------------------------------------
 Testing PG tables
(1 row)

SELECT load();
 load
---------------------------------------------------------------------

(1 row)

WITH pg_res AS (
	SELECT * FROM s1
)
MERGE INTO t1
	USING pg_res ON (pg_res.id = t1.id)
	WHEN MATCHED AND pg_res.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (pg_res.id, pg_res.val);
-- Two rows with id 2 and val incremented, id 3, and id 1 is deleted
SELECT * FROM t1 order by id;
 id | val
---------------------------------------------------------------------
  2 |   1
  3 |   1
  4 |   1
  5 |   0
  6 |   1
(5 rows)

SELECT * INTO merge_result FROM t1 order by id;
-- Test Citus local tables
TRUNCATE t1;
TRUNCATE s1;
SELECT load();
 load
---------------------------------------------------------------------

(1 row)

SELECT citus_add_local_table_to_metadata('t1');
 citus_add_local_table_to_metadata
---------------------------------------------------------------------

(1 row)

SELECT citus_add_local_table_to_metadata('s1');
 citus_add_local_table_to_metadata
---------------------------------------------------------------------

(1 row)

WITH s1_res AS (
	SELECT * FROM s1
)
MERGE INTO t1
	USING s1_res ON (s1_res.id = t1.id)
	WHEN MATCHED AND s1_res.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (s1_res.id, s1_res.val);
NOTICE:  <Deparsed MERGE query: WITH s1_res AS (SELECT s1.id, s1.val FROM merge_schema.s1_4000011 s1) MERGE INTO merge_schema.t1_4000010 t1 USING s1_res ON (s1_res.id OPERATOR(pg_catalog.=) t1.id) WHEN MATCHED AND (s1_res.val OPERATOR(pg_catalog.=) 0) THEN DELETE WHEN MATCHED THEN UPDATE SET val = (t1.val OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s1_res.id, s1_res.val)>
-- Two rows with id 2 and val incremented, id 3, and id 1 is deleted
SELECT * FROM t1 order by id;
 id | val
---------------------------------------------------------------------
  2 |   1
  3 |   1
  4 |   1
  5 |   0
  6 |   1
(5 rows)

-- Should be empty
SELECT *
FROM merge_result p
WHERE NOT EXISTS (SELECT 1 FROM t1 c WHERE c.id = p.id);
 id | val
---------------------------------------------------------------------
(0 rows)

SELECT 'Testing dist - dist';
      ?column?
---------------------------------------------------------------------
 Testing dist - dist
(1 row)

SELECT undistribute_table('t1');
NOTICE:  creating a new table for merge_schema.t1
NOTICE:  moving the data of merge_schema.t1
NOTICE:  dropping the old merge_schema.t1
NOTICE:  renaming the new table to merge_schema.t1
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT undistribute_table('s1');
NOTICE:  creating a new table for merge_schema.s1
NOTICE:  moving the data of merge_schema.s1
NOTICE:  dropping the old merge_schema.s1
NOTICE:  renaming the new table to merge_schema.s1
 undistribute_table
---------------------------------------------------------------------

(1 row)

TRUNCATE t1;
TRUNCATE s1;
SELECT load();
 load
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('t1', 'id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.t1$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('s1', 'id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.s1$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

WITH s1_res AS (
	SELECT * FROM s1
)
MERGE INTO t1
	USING s1_res ON (s1_res.id = t1.id)
	WHEN MATCHED AND s1_res.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (s1_res.id, s1_res.val);
NOTICE:  <Deparsed MERGE query: WITH s1_res AS (SELECT s1.id, s1.val FROM merge_schema.s1_4000016 s1) MERGE INTO merge_schema.t1_4000012 t1 USING s1_res ON (s1_res.id OPERATOR(pg_catalog.=) t1.id) WHEN MATCHED AND (s1_res.val OPERATOR(pg_catalog.=) 0) THEN DELETE WHEN MATCHED THEN UPDATE SET val = (t1.val OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s1_res.id, s1_res.val)>
NOTICE:  <Deparsed MERGE query: WITH s1_res AS (SELECT s1.id, s1.val FROM merge_schema.s1_4000017 s1) MERGE INTO merge_schema.t1_4000013 t1 USING s1_res ON (s1_res.id OPERATOR(pg_catalog.=) t1.id) WHEN MATCHED AND (s1_res.val OPERATOR(pg_catalog.=) 0) THEN DELETE WHEN MATCHED THEN UPDATE SET val = (t1.val OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s1_res.id, s1_res.val)>
NOTICE:  <Deparsed MERGE query: WITH s1_res AS (SELECT s1.id, s1.val FROM merge_schema.s1_4000018 s1) MERGE INTO merge_schema.t1_4000014 t1 USING s1_res ON (s1_res.id OPERATOR(pg_catalog.=) t1.id) WHEN MATCHED AND (s1_res.val OPERATOR(pg_catalog.=) 0) THEN DELETE WHEN MATCHED THEN UPDATE SET val = (t1.val OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s1_res.id, s1_res.val)>
NOTICE:  <Deparsed MERGE query: WITH s1_res AS (SELECT s1.id, s1.val FROM merge_schema.s1_4000019 s1) MERGE INTO merge_schema.t1_4000015 t1 USING s1_res ON (s1_res.id OPERATOR(pg_catalog.=) t1.id) WHEN MATCHED AND (s1_res.val OPERATOR(pg_catalog.=) 0) THEN DELETE WHEN MATCHED THEN UPDATE SET val = (t1.val OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s1_res.id, s1_res.val)>
-- Two rows with id 2 and val incremented, id 3, and id 1 is deleted
SELECT * FROM t1 order by id;
 id | val
---------------------------------------------------------------------
  2 |   1
  3 |   1
  4 |   1
  5 |   0
  6 |   1
(5 rows)

-- Both the results should be equal
SELECT c.id, c.val, p.id, p.val
FROM t1 c, merge_result p
WHERE c.id = p.id ORDER BY c.id;
 id | val | id | val
---------------------------------------------------------------------
  2 |   1 |  2 |   1
  3 |   1 |  3 |   1
  4 |   1 |  4 |   1
  5 |   0 |  5 |   0
  6 |   1 |  6 |   1
(5 rows)

-- Test EXPLAIN with CTE
EXPLAIN
WITH s1_res AS (
	SELECT * FROM s1
)
MERGE INTO t1
	USING s1_res ON (s1_res.id = t1.id)
	WHEN MATCHED AND s1_res.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (s1_res.id, s1_res.val);
NOTICE:  <Deparsed MERGE query: WITH s1_res AS (SELECT s1.id, s1.val FROM merge_schema.s1_4000016 s1) MERGE INTO merge_schema.t1_4000012 t1 USING s1_res ON (s1_res.id OPERATOR(pg_catalog.=) t1.id) WHEN MATCHED AND (s1_res.val OPERATOR(pg_catalog.=) 0) THEN DELETE WHEN MATCHED THEN UPDATE SET val = (t1.val OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s1_res.id, s1_res.val)>
NOTICE:  <Deparsed MERGE query: WITH s1_res AS (SELECT s1.id, s1.val FROM merge_schema.s1_4000017 s1) MERGE INTO merge_schema.t1_4000013 t1 USING s1_res ON (s1_res.id OPERATOR(pg_catalog.=) t1.id) WHEN MATCHED AND (s1_res.val OPERATOR(pg_catalog.=) 0) THEN DELETE WHEN MATCHED THEN UPDATE SET val = (t1.val OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s1_res.id, s1_res.val)>
NOTICE:  <Deparsed MERGE query: WITH s1_res AS (SELECT s1.id, s1.val FROM merge_schema.s1_4000018 s1) MERGE INTO merge_schema.t1_4000014 t1 USING s1_res ON (s1_res.id OPERATOR(pg_catalog.=) t1.id) WHEN MATCHED AND (s1_res.val OPERATOR(pg_catalog.=) 0) THEN DELETE WHEN MATCHED THEN UPDATE SET val = (t1.val OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s1_res.id, s1_res.val)>
NOTICE:  <Deparsed MERGE query: WITH s1_res AS (SELECT s1.id, s1.val FROM merge_schema.s1_4000019 s1) MERGE INTO merge_schema.t1_4000015 t1 USING s1_res ON (s1_res.id OPERATOR(pg_catalog.=) t1.id) WHEN MATCHED AND (s1_res.val OPERATOR(pg_catalog.=) 0) THEN DELETE WHEN MATCHED THEN UPDATE SET val = (t1.val OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s1_res.id, s1_res.val)>
                                           QUERY PLAN
---------------------------------------------------------------------
 Custom Scan (Citus Adaptive)  (cost=0.00..0.00 rows=0 width=0)
   Task Count: 4
   Tasks Shown: All
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  Merge on t1_4000012 t1  (cost=350.95..745.32 rows=0 width=0)
               ->  Merge Left Join  (cost=350.95..745.32 rows=25538 width=14)
                     Merge Cond: (s1.id = t1.id)
                     ->  Sort  (cost=158.51..164.16 rows=2260 width=8)
                           Sort Key: s1.id
                           ->  Seq Scan on s1_4000016 s1  (cost=0.00..32.60 rows=2260 width=8)
                     ->  Sort  (cost=158.51..164.16 rows=2260 width=10)
                           Sort Key: t1.id
                           ->  Seq Scan on t1_4000012 t1  (cost=0.00..32.60 rows=2260 width=10)
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  Merge on t1_4000013 t1  (cost=350.95..745.32 rows=0 width=0)
               ->  Merge Left Join  (cost=350.95..745.32 rows=25538 width=14)
                     Merge Cond: (s1.id = t1.id)
                     ->  Sort  (cost=158.51..164.16 rows=2260 width=8)
                           Sort Key: s1.id
                           ->  Seq Scan on s1_4000017 s1  (cost=0.00..32.60 rows=2260 width=8)
                     ->  Sort  (cost=158.51..164.16 rows=2260 width=10)
                           Sort Key: t1.id
                           ->  Seq Scan on t1_4000013 t1  (cost=0.00..32.60 rows=2260 width=10)
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  Merge on t1_4000014 t1  (cost=350.95..745.32 rows=0 width=0)
               ->  Merge Left Join  (cost=350.95..745.32 rows=25538 width=14)
                     Merge Cond: (s1.id = t1.id)
                     ->  Sort  (cost=158.51..164.16 rows=2260 width=8)
                           Sort Key: s1.id
                           ->  Seq Scan on s1_4000018 s1  (cost=0.00..32.60 rows=2260 width=8)
                     ->  Sort  (cost=158.51..164.16 rows=2260 width=10)
                           Sort Key: t1.id
                           ->  Seq Scan on t1_4000014 t1  (cost=0.00..32.60 rows=2260 width=10)
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  Merge on t1_4000015 t1  (cost=350.95..745.32 rows=0 width=0)
               ->  Merge Left Join  (cost=350.95..745.32 rows=25538 width=14)
                     Merge Cond: (s1.id = t1.id)
                     ->  Sort  (cost=158.51..164.16 rows=2260 width=8)
                           Sort Key: s1.id
                           ->  Seq Scan on s1_4000019 s1  (cost=0.00..32.60 rows=2260 width=8)
                     ->  Sort  (cost=158.51..164.16 rows=2260 width=10)
                           Sort Key: t1.id
                           ->  Seq Scan on t1_4000015 t1  (cost=0.00..32.60 rows=2260 width=10)
(47 rows)

--
-- Test with multiple join conditions
--
CREATE TABLE t2(id int, val int, src text);
CREATE TABLE s2(id int, val int, src text);
CREATE OR REPLACE FUNCTION insert_data() RETURNS VOID AS $$
INSERT INTO t2 VALUES(1, 0, 'target');
INSERT INTO t2 VALUES(2, 0, 'target');
INSERT INTO t2 VALUES(3, 1, 'match');
INSERT INTO t2 VALUES(4, 0, 'match');

INSERT INTO s2 VALUES(2, 0, 'source'); -- No match insert
INSERT INTO s2 VALUES(4, 0, 'match'); -- Match delete
INSERT INTO s2 VALUES(3, 10, 'match'); -- Match update

$$
LANGUAGE SQL;
SELECT 'Testing PG tables';
     ?column?
---------------------------------------------------------------------
 Testing PG tables
(1 row)

SELECT insert_data();
 insert_data
---------------------------------------------------------------------

(1 row)

MERGE INTO t2
USING s2
ON t2.id = s2.id AND t2.src = s2.src
	WHEN MATCHED AND t2.val = 1 THEN
		UPDATE SET val = s2.val + 10
	WHEN MATCHED THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT (id, val, src) VALUES (s2.id, s2.val, s2.src);
SELECT * FROM t2 ORDER BY 1;
 id | val |  src
---------------------------------------------------------------------
  1 |   0 | target
  2 |   0 | target
  2 |   0 | source
  3 |  20 | match
(4 rows)

SELECT * INTO pg_t2 FROM t2;
SELECT 'Testing Citus local tables';
          ?column?
---------------------------------------------------------------------
 Testing Citus local tables
(1 row)

TRUNCATE t2;
TRUNCATE s2;
SELECT insert_data();
 insert_data
---------------------------------------------------------------------

(1 row)

SELECT citus_add_local_table_to_metadata('t2');
 citus_add_local_table_to_metadata
---------------------------------------------------------------------

(1 row)

SELECT citus_add_local_table_to_metadata('s2');
 citus_add_local_table_to_metadata
---------------------------------------------------------------------

(1 row)

MERGE INTO t2
USING s2
ON t2.id = s2.id AND t2.src = s2.src
	WHEN MATCHED AND t2.val = 1 THEN
		UPDATE SET val = s2.val + 10
	WHEN MATCHED THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT (id, val, src) VALUES (s2.id, s2.val, s2.src);
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t2_4000020 t2 USING merge_schema.s2_4000021 s2 ON ((t2.id OPERATOR(pg_catalog.=) s2.id) AND (t2.src OPERATOR(pg_catalog.=) s2.src)) WHEN MATCHED AND (t2.val OPERATOR(pg_catalog.=) 1) THEN UPDATE SET val = (s2.val OPERATOR(pg_catalog.+) 10) WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT (id, val, src) VALUES (s2.id, s2.val, s2.src)>
SELECT * FROM t2 ORDER BY 1;
 id | val |  src
---------------------------------------------------------------------
  1 |   0 | target
  2 |   0 | target
  2 |   0 | source
  3 |  20 | match
(4 rows)

-- Should be empty
SELECT *
FROM pg_t2 p
WHERE NOT EXISTS (SELECT 1 FROM t2 c WHERE c.id = p.id);
 id | val | src
---------------------------------------------------------------------
(0 rows)

SELECT 'Testing Dist - Dist';
      ?column?
---------------------------------------------------------------------
 Testing Dist - Dist
(1 row)

-- Clean the slate
TRUNCATE t2;
TRUNCATE s2;
SELECT insert_data();
 insert_data
---------------------------------------------------------------------

(1 row)

SELECT undistribute_table('t2');
NOTICE:  creating a new table for merge_schema.t2
NOTICE:  moving the data of merge_schema.t2
NOTICE:  dropping the old merge_schema.t2
NOTICE:  renaming the new table to merge_schema.t2
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT undistribute_table('s2');
NOTICE:  creating a new table for merge_schema.s2
NOTICE:  moving the data of merge_schema.s2
NOTICE:  dropping the old merge_schema.s2
NOTICE:  renaming the new table to merge_schema.s2
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('t2', 'id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.t2$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('s2', 'id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.s2$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

MERGE INTO t2
USING s2
ON t2.id = s2.id AND t2.src = s2.src
	WHEN MATCHED AND t2.val = 1 THEN
		UPDATE SET val = s2.val + 10
	WHEN MATCHED THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT (id, val, src) VALUES (s2.id, s2.val, s2.src);
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t2_4000022 t2 USING merge_schema.s2_4000026 s2 ON ((t2.id OPERATOR(pg_catalog.=) s2.id) AND (t2.src OPERATOR(pg_catalog.=) s2.src)) WHEN MATCHED AND (t2.val OPERATOR(pg_catalog.=) 1) THEN UPDATE SET val = (s2.val OPERATOR(pg_catalog.+) 10) WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT (id, val, src) VALUES (s2.id, s2.val, s2.src)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t2_4000023 t2 USING merge_schema.s2_4000027 s2 ON ((t2.id OPERATOR(pg_catalog.=) s2.id) AND (t2.src OPERATOR(pg_catalog.=) s2.src)) WHEN MATCHED AND (t2.val OPERATOR(pg_catalog.=) 1) THEN UPDATE SET val = (s2.val OPERATOR(pg_catalog.+) 10) WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT (id, val, src) VALUES (s2.id, s2.val, s2.src)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t2_4000024 t2 USING merge_schema.s2_4000028 s2 ON ((t2.id OPERATOR(pg_catalog.=) s2.id) AND (t2.src OPERATOR(pg_catalog.=) s2.src)) WHEN MATCHED AND (t2.val OPERATOR(pg_catalog.=) 1) THEN UPDATE SET val = (s2.val OPERATOR(pg_catalog.+) 10) WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT (id, val, src) VALUES (s2.id, s2.val, s2.src)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t2_4000025 t2 USING merge_schema.s2_4000029 s2 ON ((t2.id OPERATOR(pg_catalog.=) s2.id) AND (t2.src OPERATOR(pg_catalog.=) s2.src)) WHEN MATCHED AND (t2.val OPERATOR(pg_catalog.=) 1) THEN UPDATE SET val = (s2.val OPERATOR(pg_catalog.+) 10) WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT (id, val, src) VALUES (s2.id, s2.val, s2.src)>
SELECT * FROM t2 ORDER BY 1;
 id | val |  src
---------------------------------------------------------------------
  1 |   0 | target
  2 |   0 | target
  2 |   0 | source
  3 |  20 | match
(4 rows)

SELECT * INTO dist_t2 FROM t2 ORDER BY 1;
-- Should be equal
SELECT c.*, p.*
FROM t2 c,pg_t2 p
WHERE c.id = p.id AND c.src = p.src
ORDER BY 1,2;
 id | val |  src   | id | val |  src
---------------------------------------------------------------------
  1 |   0 | target |  1 |   0 | target
  2 |   0 | target |  2 |   0 | target
  2 |   0 | source |  2 |   0 | source
  3 |  20 | match  |  3 |  20 | match
(4 rows)

-- Should be empty
SELECT *
FROM pg_t2 p
WHERE NOT EXISTS (SELECT 1 FROM dist_t2 c WHERE c.id = p.id);
 id | val | src
---------------------------------------------------------------------
(0 rows)

--
-- With sub-query as the MERGE source
--
TRUNCATE t2;
TRUNCATE s2;
SELECT insert_data();
 insert_data
---------------------------------------------------------------------

(1 row)

MERGE INTO t2 t
USING (SELECT * FROM s2) s
ON t.id = s.id AND t.src = s.src
	WHEN MATCHED AND t.val = 1 THEN
		UPDATE SET val = s.val + 10
	WHEN MATCHED THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT (id, val, src) VALUES (s.id, s.val, s.src);
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t2_4000022 t USING (SELECT s2.id, s2.val, s2.src FROM merge_schema.s2_4000026 s2) s ON ((t.id OPERATOR(pg_catalog.=) s.id) AND (t.src OPERATOR(pg_catalog.=) s.src)) WHEN MATCHED AND (t.val OPERATOR(pg_catalog.=) 1) THEN UPDATE SET val = (s.val OPERATOR(pg_catalog.+) 10) WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT (id, val, src) VALUES (s.id, s.val, s.src)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t2_4000023 t USING (SELECT s2.id, s2.val, s2.src FROM merge_schema.s2_4000027 s2) s ON ((t.id OPERATOR(pg_catalog.=) s.id) AND (t.src OPERATOR(pg_catalog.=) s.src)) WHEN MATCHED AND (t.val OPERATOR(pg_catalog.=) 1) THEN UPDATE SET val = (s.val OPERATOR(pg_catalog.+) 10) WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT (id, val, src) VALUES (s.id, s.val, s.src)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t2_4000024 t USING (SELECT s2.id, s2.val, s2.src FROM merge_schema.s2_4000028 s2) s ON ((t.id OPERATOR(pg_catalog.=) s.id) AND (t.src OPERATOR(pg_catalog.=) s.src)) WHEN MATCHED AND (t.val OPERATOR(pg_catalog.=) 1) THEN UPDATE SET val = (s.val OPERATOR(pg_catalog.+) 10) WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT (id, val, src) VALUES (s.id, s.val, s.src)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t2_4000025 t USING (SELECT s2.id, s2.val, s2.src FROM merge_schema.s2_4000029 s2) s ON ((t.id OPERATOR(pg_catalog.=) s.id) AND (t.src OPERATOR(pg_catalog.=) s.src)) WHEN MATCHED AND (t.val OPERATOR(pg_catalog.=) 1) THEN UPDATE SET val = (s.val OPERATOR(pg_catalog.+) 10) WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT (id, val, src) VALUES (s.id, s.val, s.src)>
SELECT * FROM t2 ORDER BY 1;
 id | val |  src
---------------------------------------------------------------------
  1 |   0 | target
  2 |   0 | target
  2 |   0 | source
  3 |  20 | match
(4 rows)

SELECT * INTO dist_res FROM t2 ORDER BY 1;
-- Should be equal
SELECT c.*, p.*
FROM t2 c, pg_t2 p
WHERE c.id = p.id AND c.src = p.src
ORDER BY 1,2;
 id | val |  src   | id | val |  src
---------------------------------------------------------------------
  1 |   0 | target |  1 |   0 | target
  2 |   0 | target |  2 |   0 | target
  2 |   0 | source |  2 |   0 | source
  3 |  20 | match  |  3 |  20 | match
(4 rows)

-- Should be empty
SELECT *
FROM pg_t2 p
WHERE NOT EXISTS (SELECT 1 FROM dist_res c WHERE c.id = p.id);
 id | val | src
---------------------------------------------------------------------
(0 rows)

--
-- Using two source tables
--
CREATE TABLE t3(id int, val int, src text);
CREATE TABLE s3_1(id int, val int, src text);
CREATE TABLE s3_2(id int, val int, src text);
CREATE OR REPLACE FUNCTION insert_data() RETURNS VOID AS $$
INSERT INTO t3 VALUES(1, 0, 'target'); -- Intact
INSERT INTO t3 VALUES(2, 0, 'target');
INSERT INTO t3 VALUES(3, 0, 'target');
INSERT INTO t3 VALUES(5, 0, 'target'); -- Intact

INSERT INTO s3_1 VALUES(2, 0, 'source1');
INSERT INTO s3_1 VALUES(3, 0, 'source1');
INSERT INTO s3_1 VALUES(4, 0, 'source1');

INSERT INTO s3_2 VALUES(2, 1, 'source2'); -- Match update
INSERT INTO s3_2 VALUES(3, 0, 'source2'); -- Match delete
INSERT INTO s3_2 VALUES(4, 0, 'source2'); -- No match insert
INSERT INTO s3_2 VALUES(6, 0, 'source2'); -- Will miss the source-subquery-join
$$
LANGUAGE SQL;
SELECT insert_data();
 insert_data
---------------------------------------------------------------------

(1 row)

MERGE INTO t3
	USING (SELECT s3_1.id, s3_2.val, s3_2.src FROM s3_1, s3_2 WHERE s3_1.id = s3_2.id) sub
	ON (t3.id = sub.id)
	WHEN MATCHED AND sub.val = 1 THEN
		UPDATE SET val = t3.val + 10
	WHEN MATCHED THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT (id, val, src) VALUES (sub.id, sub.val, sub.src);
SELECT * FROM t3 ORDER BY 1;
 id | val |   src
---------------------------------------------------------------------
  1 |   0 | target
  2 |  10 | target
  4 |   0 | source2
  5 |   0 | target
(4 rows)

SELECT * INTO pg_t3 FROM t3 ORDER BY 1;
SELECT 'Testing dist - dist';
      ?column?
---------------------------------------------------------------------
 Testing dist - dist
(1 row)

TRUNCATE t3;
TRUNCATE s3_1;
TRUNCATE s3_2;
SELECT insert_data();
 insert_data
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('t3', 'id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.t3$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('s3_1', 'id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.s3_1$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('s3_2', 'id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.s3_2$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

MERGE INTO t3
	USING (SELECT s3_1.id, s3_2.val, s3_2.src FROM s3_1, s3_2 WHERE s3_1.id = s3_2.id) sub
	ON (t3.id = sub.id)
	WHEN MATCHED AND sub.val = 1 THEN
		UPDATE SET val = t3.val + 10
	WHEN MATCHED THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT (id, val, src) VALUES (sub.id, sub.val, sub.src);
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t3_4000030 t3 USING (SELECT s3_1.id, s3_2.val, s3_2.src FROM merge_schema.s3_1_4000034 s3_1, merge_schema.s3_2_4000038 s3_2 WHERE (s3_1.id OPERATOR(pg_catalog.=) s3_2.id)) sub ON (t3.id OPERATOR(pg_catalog.=) sub.id) WHEN MATCHED AND (sub.val OPERATOR(pg_catalog.=) 1) THEN UPDATE SET val = (t3.val OPERATOR(pg_catalog.+) 10) WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT (id, val, src) VALUES (sub.id, sub.val, sub.src)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t3_4000031 t3 USING (SELECT s3_1.id, s3_2.val, s3_2.src FROM merge_schema.s3_1_4000035 s3_1, merge_schema.s3_2_4000039 s3_2 WHERE (s3_1.id OPERATOR(pg_catalog.=) s3_2.id)) sub ON (t3.id OPERATOR(pg_catalog.=) sub.id) WHEN MATCHED AND (sub.val OPERATOR(pg_catalog.=) 1) THEN UPDATE SET val = (t3.val OPERATOR(pg_catalog.+) 10) WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT (id, val, src) VALUES (sub.id, sub.val, sub.src)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t3_4000032 t3 USING (SELECT s3_1.id, s3_2.val, s3_2.src FROM merge_schema.s3_1_4000036 s3_1, merge_schema.s3_2_4000040 s3_2 WHERE (s3_1.id OPERATOR(pg_catalog.=) s3_2.id)) sub ON (t3.id OPERATOR(pg_catalog.=) sub.id) WHEN MATCHED AND (sub.val OPERATOR(pg_catalog.=) 1) THEN UPDATE SET val = (t3.val OPERATOR(pg_catalog.+) 10) WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT (id, val, src) VALUES (sub.id, sub.val, sub.src)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t3_4000033 t3 USING (SELECT s3_1.id, s3_2.val, s3_2.src FROM merge_schema.s3_1_4000037 s3_1, merge_schema.s3_2_4000041 s3_2 WHERE (s3_1.id OPERATOR(pg_catalog.=) s3_2.id)) sub ON (t3.id OPERATOR(pg_catalog.=) sub.id) WHEN MATCHED AND (sub.val OPERATOR(pg_catalog.=) 1) THEN UPDATE SET val = (t3.val OPERATOR(pg_catalog.+) 10) WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT (id, val, src) VALUES (sub.id, sub.val, sub.src)>
SELECT * FROM t3 ORDER BY 1;
 id | val |   src
---------------------------------------------------------------------
  1 |   0 | target
  2 |  10 | target
  4 |   0 | source2
  5 |   0 | target
(4 rows)

SELECT * INTO dist_t3 FROM t3 ORDER BY 1;
-- Should be equal
SELECT c.*, p.*
FROM t3 c, pg_t3 p
WHERE c.id = p.id
ORDER BY 1,2;
 id | val |   src   | id | val |   src
---------------------------------------------------------------------
  1 |   0 | target  |  1 |   0 | target
  2 |  10 | target  |  2 |  10 | target
  4 |   0 | source2 |  4 |   0 | source2
  5 |   0 | target  |  5 |   0 | target
(4 rows)

-- Should be empty
SELECT *
FROM pg_t3 p
WHERE NOT EXISTS (SELECT 1 FROM dist_t3 c WHERE c.id = p.id);
 id | val | src
---------------------------------------------------------------------
(0 rows)

--
-- Error and Unsupported scenarios
--
TRUNCATE t1;
TRUNCATE s1;
SELECT load();
 load
---------------------------------------------------------------------

(1 row)

-- Not joining on partition columns
MERGE INTO t1
	USING s1 ON (s1.id = t1.val) -- val is not a distribution column
	WHEN MATCHED AND s1.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (s1.id, s1.val);
ERROR:  MERGE ON join condition is supported when all distributed tables are co-located and joined on their distribution columns
-- Not joining on partition columns with sub-query
MERGE INTO t1
	USING (SELECT * FROM s1) sub ON (sub.val = t1.id) -- sub.val is not a distribution column
	WHEN MATCHED AND sub.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (sub.id, sub.val);
ERROR:  MERGE ON join condition is supported when all distributed tables are co-located and joined on their distribution columns
-- Not joining on partition columns with CTE
WITH s1_res AS (
	SELECT * FROM s1
)
MERGE INTO t1
	USING s1_res ON (s1_res.val = t1.id)
	WHEN MATCHED AND s1_res.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (s1_res.id, s1_res.val);
ERROR:  MERGE ON join condition is supported when all distributed tables are co-located and joined on their distribution columns
-- Not joining on partition columns inside the sub-query
MERGE INTO t3
	-- s3_2.val is not a distribution column
	USING (SELECT s3_1.id, s3_2.val, s3_2.src FROM s3_1, s3_2 WHERE s3_1.id = s3_2.val) sub
	ON (t3.id = sub.id)
	WHEN MATCHED AND sub.val = 1 THEN
		UPDATE SET val = t3.val + 10
	WHEN MATCHED THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT (id, val, src) VALUES (sub.id, sub.val, sub.src);
ERROR:  MERGE ON join condition is supported when all distributed tables are co-located and joined on their distribution columns
-- Constant Join condition
WITH s1_res AS (
	SELECT * FROM s1
)
MERGE INTO t1
	USING s1_res ON (TRUE)
	WHEN MATCHED AND s1_res.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (s1_res.id, s1_res.val);
ERROR:  MERGE ON join condition is supported when all distributed tables are co-located and joined on their distribution columns
-- With a single WHEN clause, which causes a non-left join
WITH s1_res AS (
     SELECT * FROM s1
 )
 MERGE INTO t1 USING s1_res ON (s1_res.id = t1.val)
 WHEN MATCHED THEN DELETE
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (s1_res.id, s1_res.val);
ERROR:  MERGE ON join condition is supported when all distributed tables are co-located and joined on their distribution columns
--
-- Tables not co-located
--
SELECT undistribute_table('t1');
NOTICE:  creating a new table for merge_schema.t1
NOTICE:  moving the data of merge_schema.t1
NOTICE:  dropping the old merge_schema.t1
NOTICE:  renaming the new table to merge_schema.t1
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT undistribute_table('s1');
NOTICE:  creating a new table for merge_schema.s1
NOTICE:  moving the data of merge_schema.s1
NOTICE:  dropping the old merge_schema.s1
NOTICE:  renaming the new table to merge_schema.s1
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('t1', 'id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.t1$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('s1', 'id', colocate_with => 'none');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.s1$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

MERGE INTO t1
	USING s1 ON (s1.id = t1.id)
	WHEN MATCHED AND s1.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (s1.id, s1.val);
ERROR:  For MERGE command all the tables must be colocated
MERGE INTO t1
	USING (SELECT * FROM s1) sub ON (sub.id = t1.id) -- Non co-located table in subquery
	WHEN MATCHED AND sub.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (sub.id, sub.val);
ERROR:  For MERGE command all the tables must be colocated
--
-- Reference tables
--
SELECT undistribute_table('t1');
NOTICE:  creating a new table for merge_schema.t1
NOTICE:  moving the data of merge_schema.t1
NOTICE:  dropping the old merge_schema.t1
NOTICE:  renaming the new table to merge_schema.t1
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT undistribute_table('s1');
NOTICE:  creating a new table for merge_schema.s1
NOTICE:  moving the data of merge_schema.s1
NOTICE:  dropping the old merge_schema.s1
NOTICE:  renaming the new table to merge_schema.s1
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT create_reference_table('t1');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.t1$$)
 create_reference_table
---------------------------------------------------------------------

(1 row)

SELECT create_reference_table('s1');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.s1$$)
 create_reference_table
---------------------------------------------------------------------

(1 row)

MERGE INTO t1
	USING s1 ON (s1.id = t1.id)
	WHEN MATCHED AND s1.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (s1.id, s1.val);
ERROR:  MERGE command is not supported on Reference tables yet
--
-- Citus-Local + Citus-Distributed table
--
SELECT undistribute_table('t1');
NOTICE:  creating a new table for merge_schema.t1
NOTICE:  moving the data of merge_schema.t1
NOTICE:  dropping the old merge_schema.t1
NOTICE:  renaming the new table to merge_schema.t1
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT undistribute_table('s1');
NOTICE:  creating a new table for merge_schema.s1
NOTICE:  moving the data of merge_schema.s1
NOTICE:  dropping the old merge_schema.s1
NOTICE:  renaming the new table to merge_schema.s1
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('t1', 'id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.t1$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT citus_add_local_table_to_metadata('s1');
 citus_add_local_table_to_metadata
---------------------------------------------------------------------

(1 row)

MERGE INTO t1
	USING s1 ON (s1.id = t1.id)
	WHEN MATCHED AND s1.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (s1.id, s1.val);
ERROR:  MERGE command is not supported on combination of Citus local and distributed tables
MERGE INTO t1
	USING (SELECT * FROM s1) sub ON (sub.id = t1.id)
	WHEN MATCHED AND sub.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (sub.id, sub.val);
ERROR:  MERGE command is not supported on combination of Citus local and distributed tables
CREATE TABLE pg(val int);
SELECT undistribute_table('s1');
NOTICE:  creating a new table for merge_schema.s1
NOTICE:  moving the data of merge_schema.s1
NOTICE:  dropping the old merge_schema.s1
NOTICE:  renaming the new table to merge_schema.s1
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('s1', 'id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.s1$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

-- Both t1 and s1 are citus distributed tables now, mix Postgres table in sub-query
MERGE INTO t1
	USING (SELECT s1.id, pg.val FROM s1, pg) sub ON (sub.id = t1.id)
	WHEN MATCHED AND sub.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (sub.id, sub.val);
ERROR:  MERGE command is not supported with combination of Postgres and Citus tables
-- Mix Postgres table in CTE
WITH pg_res AS (
	SELECT * FROM pg
)
MERGE INTO t1
	USING (SELECT s1.id, pg_res.val FROM s1, pg_res) sub ON (sub.id = t1.id)
	WHEN MATCHED AND sub.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (sub.id, sub.val);
ERROR:  MERGE command is not supported with combination of Postgres and Citus tables
-- Bad Join condition
MERGE INTO t1 t
USING s1 s
ON t.id != s.id
WHEN NOT MATCHED THEN
        INSERT (id, val) VALUES (s.id, s.val);
ERROR:  MERGE ON join condition is supported when all distributed tables are co-located and joined on their distribution columns
-- Match more than one source row should fail same as Postgres behavior
SELECT undistribute_table('t1');
NOTICE:  creating a new table for merge_schema.t1
NOTICE:  moving the data of merge_schema.t1
NOTICE:  dropping the old merge_schema.t1
NOTICE:  renaming the new table to merge_schema.t1
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT undistribute_table('s1');
NOTICE:  creating a new table for merge_schema.s1
NOTICE:  moving the data of merge_schema.s1
NOTICE:  dropping the old merge_schema.s1
NOTICE:  renaming the new table to merge_schema.s1
 undistribute_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('t1', 'id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.t1$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('s1', 'id');
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$merge_schema.s1$$)
 create_distributed_table
---------------------------------------------------------------------

(1 row)

INSERT INTO s1 VALUES(1, 1); -- From load(), we already have row with id = 1
MERGE INTO t1
	USING s1 ON (s1.id = t1.id)
	WHEN MATCHED AND s1.val = 0 THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET val = t1.val + 1
	WHEN NOT MATCHED THEN
		INSERT (id, val) VALUES (s1.id, s1.val);
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t1_4000061 t1 USING merge_schema.s1_4000065 s1 ON (s1.id OPERATOR(pg_catalog.=) t1.id) WHEN MATCHED AND (s1.val OPERATOR(pg_catalog.=) 0) THEN DELETE WHEN MATCHED THEN UPDATE SET val = (t1.val OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s1.id, s1.val)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t1_4000062 t1 USING merge_schema.s1_4000066 s1 ON (s1.id OPERATOR(pg_catalog.=) t1.id) WHEN MATCHED AND (s1.val OPERATOR(pg_catalog.=) 0) THEN DELETE WHEN MATCHED THEN UPDATE SET val = (t1.val OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s1.id, s1.val)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t1_4000063 t1 USING merge_schema.s1_4000067 s1 ON (s1.id OPERATOR(pg_catalog.=) t1.id) WHEN MATCHED AND (s1.val OPERATOR(pg_catalog.=) 0) THEN DELETE WHEN MATCHED THEN UPDATE SET val = (t1.val OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s1.id, s1.val)>
NOTICE:  <Deparsed MERGE query: MERGE INTO merge_schema.t1_4000064 t1 USING merge_schema.s1_4000068 s1 ON (s1.id OPERATOR(pg_catalog.=) t1.id) WHEN MATCHED AND (s1.val OPERATOR(pg_catalog.=) 0) THEN DELETE WHEN MATCHED THEN UPDATE SET val = (t1.val OPERATOR(pg_catalog.+) 1) WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s1.id, s1.val)>
ERROR:  MERGE command cannot affect row a second time
HINT:  Ensure that not more than one source row matches any one target row.
CONTEXT:  while executing command on localhost:xxxxx
DROP SCHEMA merge_schema CASCADE;
NOTICE:  drop cascades to 21 other objects
DETAIL:  drop cascades to function insert_data()
drop cascades to table pg_result
drop cascades to table local_local
drop cascades to table target
drop cascades to table source
drop cascades to table dist_dist
drop cascades to function load()
drop cascades to table merge_result
drop cascades to table pg_t2
drop cascades to table t2
drop cascades to table s2
drop cascades to table dist_t2
drop cascades to table dist_res
drop cascades to table t3
drop cascades to table s3_1
drop cascades to table s3_2
drop cascades to table pg_t3
drop cascades to table dist_t3
drop cascades to table pg
drop cascades to table t1
drop cascades to table s1
SELECT 1 FROM master_set_node_property('localhost', :master_port, 'shouldhaveshards', false);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM master_remove_node('localhost', :master_port);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

